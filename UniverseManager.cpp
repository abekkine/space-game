#include "UniverseManager.h"

#include "SpaceShip.h"
#include "SolarSystemInterface.h"
#include "SolarSystemFactory.h"
#include "EffectsManager.h"
#include "ObjectManager.h"
#include "CollisionHandler.h"
#include "GameTimer.hpp"
#include "Universe.h"
#include "MapView.hpp"

#include <iostream>

#include <GLFW/glfw3.h>

UniverseManager::UniverseManager()
: kThreadSleepDuration(10)
, world_(0)
, solar_system_(0)
, space_ship_(0)
, effects_(0)
, state_(GameDefinitions::gameState_InMenu)
, quit_(false)
, show_map_(false)
, paused_(false)
{
    map_x_ = map_y_ = -1.0;
}

UniverseManager::~UniverseManager() {

    thread_.join();

    OBJMGR.Remove("effects");
    OBJMGR.Remove("ship");
    OBJMGR.Remove("solar");

    delete collision_handler_;
    delete world_;
}

void UniverseManager::SetState(GameDefinitions::GameStateEnum state) {
    state_ = state;
}

void UniverseManager::Exit() {
    quit_ = true;
}

void UniverseManager::Init() {
    // No gravity, since gravity will be modeled manually.
    b2Vec2 gravity(0.0f, 0.0f);
    world_ = new b2World(gravity);

    effects_ = std::make_shared<EffectsManager>();
    effects_->Init();
    OBJMGR.Set("effects", effects_);

    // Instantiate player ship.
    space_ship_ = std::make_shared<SpaceShip>();
    space_ship_->SetPosition(0.0, 110.0);
    space_ship_->SetAngle(0.0);
    OBJMGR.Set("ship", space_ship_);

    universe_ = std::make_shared<Universe>();
    OBJMGR.Set("universe", universe_);

    map_ = new MapView();
    map_->Init(universe_);

    // Instantiate planets & solar system.
    // Solar system will be generated by seed from current star.
    UpdateMap();

    SetSolarSystem(map_->GetCenterStar());

    // Player creation
    space_ship_->Init(world_);

    // Initialize physics.
    collision_handler_ = new CollisionHandler();
    world_->SetContactListener(collision_handler_);

    // Initialize timer.
    timer_.Init();
}

void UniverseManager::SetSolarSystem(StarInterface * star) {
    #ifdef ENABLE_TEST_SYSTEM
    solar_system_ = SolarSystemFactory::getTestingSystem(world_);
    #else
    if (star != 0) {
        solar_system_ = SolarSystemFactory::getStarSystem(world_);
    } else {
        solar_system_ = SolarSystemFactory::getEmptySystem(world_);
    }
    #endif

    solar_system_->SetStar(star);
    OBJMGR.Set("solar", solar_system_, true);
}

void UniverseManager::Run() {

    thread_ = std::thread(&UniverseManager::ThreadLoop, this);
}

void UniverseManager::ToggleMap() {
    show_map_ = ! show_map_;
}

void UniverseManager::TogglePause() {
    paused_ = ! paused_;
}

void UniverseManager::Render() {

    if (quit_) return;

    solar_system_->Render();

    effects_->Render();

    if (show_map_) {
        map_->Render();
    }
}

void UniverseManager::ThreadLoop() {
    while (!quit_) {

        double delta_time = timer_.GetElapsed();

        if (! paused_) {
            space_ship_->Update(delta_time);

            solar_system_->Update(delta_time);

            effects_->Update(delta_time);

            // Advance physics
            if (state_ != GameDefinitions::gameState_InGame) {
                world_->Step(0.0, 12, 6);
            }
            else {
                world_->Step(delta_time, 12, 6);
            }

            UpdateMap();
        }

        GameTimer::Sleep(kThreadSleepDuration);
    }
}

void UniverseManager::UpdateMap() {
    double map_x, map_y;
    space_ship_->GetMapPosition(map_x, map_y);
    if (map_x != map_x_ || map_y != map_y_) {
        map_x_ = map_x;
        map_y_ = map_y;
        map_->Update(map_x_, map_y_);
    }
}
